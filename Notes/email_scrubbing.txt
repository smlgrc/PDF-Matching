import json
import os

import PyPDF2
import pandas
import pywintypes
import win32com.client
from win32com.client.dynamic import CDispatch
from datetime import datetime
from PyPDF2 import PdfReader, PdfFileReader, PageObject
import magic
import zipfile
from pptx import Presentation
import os.path
import pathlib
import olefile

# Connect to Outlook
outlook: CDispatch = win32com.client.Dispatch(
    "Outlook.Application").GetNamespace("MAPI")

sam_outlook_account: win32com.client.CDispatch = outlook.GetDefaultFolder(6)
randy_outlook_account: win32com.client.CDispatch = outlook.Folders[
    "Randy Customers Email"]
lisa_outlook_account_1: win32com.client.CDispatch = outlook.Folders[
    "Lisa Customers Email 1"]
lisa_outlook_account_2: win32com.client.CDispatch = outlook.Folders[
    "Lisa Customers Email 2"]

user_inbox_name = "Lisa Inbox 1"  # "Lisa Inbox 1"
user_inbox = lisa_outlook_account_1

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\email_testing\create_email_folder_testing', f'{user_inbox_name} Attachments')

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\casi_testing\json_files_for_casi', f'{user_inbox_name} Attachments')

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\email_testing\email_simulation', f'{user_inbox_name} Attachments')

# base_path: str = os.path.join(r'C:\Users\sga\Documents\Notes\temp files', f'{user_inbox_name} Attachments')

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\casi_testing\split_json_testing\split json files version 4 - split size 1')

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\casi_testing\split_json_testing\split json files version 1\Randy Inbox split json files 1')

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\casi_testing\Randy Inbox email 449')

base_path: str = os.path.join(
    r"C:\Users\sga\Desktop\email_testing\email_simulation_2\Lisa Inbox 2 Attachments")
output_json_path: str = os.path.join(
    r"C:\Users\sga\Desktop\email_testing\email_simulation_2\Lisa Inbox 2 Json Files")

email_list = []
email_counter = 0

casi_file_list = []
casi_file_counter = 0
casi_json_counter = 0


def file_ext_analysis(rootdir):
    file_types = {}

    for subdir, dirs, files in os.walk(rootdir):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """
        for file in files:
            path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(path)
            root = root_and_ext[0]
            ext = root_and_ext[1]

            # my tool to check the types of files im looking at
            if ext.lower() == '.msg':
                print('\n' + path)
                print(magic.from_file(path))
                print(magic.from_file(path, mime=True) + '\n')

                # msg = outlook.OpenSharedItem(path)
                # msg_a = msg.Attachments
                # breakpoint()
                # msg.Close(0)

            # if ext.lower() == '.zip':
            #     breakpoint()
            if ext in file_types:
                file_types[ext] += 1
            else:
                file_types[ext] = 1
    # counter += if_counter + else_counter
    # breakpoint()
    sorted_list: list = sorted(file_types.items(), key=lambda item: item[1])[::-1]
    sorted_dict = dict(sorted_list)
    for key, value in sorted_dict.items():
        print(key + ' : ' + str(value))


# def json_extract(attachment_path: str) -> dict:


def pptx_extract(attachment_path: str) -> dict:
    # creating an object
    pptx = Presentation(attachment_path)

    text_list = []

    # print text from powerpoint
    for slide in pptx.slides:
        for shape in slide.shapes:
            if not shape.has_text_frame:
                continue
            for paragraph in shape.text_frame.paragraphs:
                for run in paragraph.runs:
                    # print('\n' + run.text)
                    text_list.append(run.text)
    # for i in text_list:
    #     print(i)
    fileText = ' '.join(text_list)

    attachment_dict: dict = \
        {
            'file_path': attachment_path,
            'file_content': fileText
        }
    return attachment_dict


def ppt_extract(attachment_path: str) -> dict:
    ppt_app = win32com.client.GetObject(attachment_path)

    text_list = []

    for slide in ppt_app.Slides:
        for shape in slide.Shapes:
            if not shape.HasTextFrame:
                continue
            for lines in shape.TextFrame.TextRange:
                text_list.append(lines.text)
    # for i in text_list:
    #     print(i)
    fileText = ' '.join(text_list)

    attachment_dict: dict = \
        {
            'file_path': attachment_path,
            'file_content': fileText
        }
    ppt_app.Close()
    return attachment_dict


def pdf_extract(attachment_path: str) -> dict:
    pdfFileObj = open(attachment_path, 'rb')
    pdfTxt: str = ''
    try:
        pdfReader: PdfFileReader = PyPDF2.PdfFileReader(pdfFileObj, strict=False)
        print('Number of PDF pages = ' + str(pdfReader.numPages))

        pdfPages: list[PageObject] = pdfReader.pages

        print('\n=== Page Extracts ===')
        for i in range(len(pdfPages)):
            pageNum = i + 1
            pageObj: PageObject = pdfReader.getPage(i)
            pageTxt: str = pageObj.extractText()
            pdfTxt += pageTxt
    except Exception as e:  # PyPDF2.errors.PdfReadError:
        print(e)
    finally:
        attachment_dict: dict = \
            {
                'file_path': attachment_path,
                'file_content': pdfTxt
            }
        # attachment_list.append(attachment_dict)
    pdfFileObj.close()
    return attachment_dict


def txt_extract(attachment_path: str) -> dict:
    fileText = ''
    with open(attachment_path, encoding="utf8", errors='ignore') as f:
        lines = f.readlines()
        fileText = ''.join(lines)

    attachment_dict: dict = \
        {
            'file_path': attachment_path,
            'file_content': fileText
        }
    return attachment_dict


def xls_extract(attachment_path: str, ext: str) -> dict:
    attachment_dict = {}
    eng: str = "xlrd"

    if ext.lower() == '.xlsx' or ext.lower() == '.xlsm':
        eng = "openpyxl"
    elif ext.lower() == '.xlsb':
        eng = "pyxlsb"

    # read all sheets together.
    all_sheets_df = pandas.read_excel(attachment_path, na_values="Missing",
                                      na_filter=False, sheet_name=None,
                                      engine=eng)  # idk about the warning
    content = ''
    for key, value in all_sheets_df.items():
        content += '\n' + key + ' : ' + str(value)
    attachment_dict['file_path'] = attachment_path
    attachment_dict['file_content'] = content
    return attachment_dict


def doc_extract(attachment_path: str) -> dict:
    attachment_dict = {}
    word = win32com.client.Dispatch("Word.Application")
    word.visible = False
    wb = word.Documents.Open(attachment_path)
    doc = word.ActiveDocument
    content = str(doc.Content)
    attachment_dict['file_path'] = attachment_path
    attachment_dict['file_content'] = content
    doc.Close()
    return attachment_dict


def unzip_files(rootdir):
    for subdir, dirs, files in os.walk(rootdir):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """
        for file in files:
            path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(path)
            root = root_and_ext[0]
            ext = root_and_ext[1]

            # breakpoint()
            if ext.lower() == '.zip':
                zipFileName_and_ext = os.path.splitext(file)
                zipFileName = zipFileName_and_ext[0]
                zip_ext = zipFileName_and_ext[1]
                try:
                    with zipfile.ZipFile(path, 'r') as zip_ref:
                        # zip_ref.extractall(subdir)

                        counter = 0
                        zipinfos = zip_ref.infolist()

                        # iterate through each file in zip folder
                        for zipinfo in zipinfos:
                            counter += 1

                            # fileName = 'file1' | fileName_ext = '.pdf'
                            fileName_and_ext = os.path.splitext(zipinfo.filename)
                            fileName = fileName_and_ext[0]
                            fileName_ext = fileName_and_ext[1]

                            new_file_name = fileName + f'_zipExtract_' \
                                            + str(counter) + fileName_ext

                            # modify the name of the file before extracting
                            zipinfo.filename = new_file_name
                            zip_ref.extract(zipinfo, subdir)

                except Exception as e:
                    print(e)


def process_msg_files(msg_path: str, target_folder_path: str):
    attachment_msg = outlook.OpenSharedItem(msg_path)
    senderEmail = attachment_msg.SenderEmailAddress  # 43, # 57, 56
    sentOn = attachment_msg.SentOn  # 43, 57, 56
    senderName = attachment_msg.SenderName  # 43, 57, 56
    subjectMsg = attachment_msg.Subject  # 43, 57, 56
    attachmentsMsg = attachment_msg.Attachments  # 43, 57, 56
    bodyMsg = attachment_msg.body  # 43, 57, 56
    attachment_names = ''

    # checks if there are attachments in the email
    if attachmentsMsg.Count > 0:
        # Save attachments
        a_counter = 0
        for attachment in attachmentsMsg:
            a_counter += 1
            try:
                fileName_and_ext = os.path.splitext(attachment.FileName)
                fileName = fileName_and_ext[0]
                ext = fileName_and_ext[1]
                attachment_names += attachment.FileName + ' '

                new_attachment_name = fileName + '_msgExtract_' + \
                                      str(a_counter) + ext
                attachment_path = os.path.join(target_folder_path,
                                               str(new_attachment_name))
                attachment.SaveAsFile(attachment_path)  # saves attachment locally
                # # new, doesn't work
                # if ext.lower() == '.msg':
                #     breakpoint()
                #     new_msg_folder_path = os.path.join(target_folder_path, fileName)
                #     os.mkdir(new_msg_folder_path)
                #     breakpoint()
                #     # process_msg_files(attachment_path, new_msg_folder_path)
            except (pywintypes.com_error, PyPDF2.errors.DependencyError,
                    PyPDF2.errors.PdfReadError) \
                    as error:
                print(error)
    email_content = f'\nsender_email: {senderEmail}' \
                    f'\nsent_on: {str(sentOn)}' \
                    f'\nsender_name: {senderName}' \
                    f'\nsubject: {subjectMsg}' \
                    f'\nattachment_names: {attachment_names}' \
                    f'\nbody: {bodyMsg}'

    # creates a txt file with all the email details in it
    # extra_email_details_path = os.path.join(target_folder_path, f'EXTRA EMAIL details.txt')
    # creates a txt file with all the email details in it
    msg_name_complete = os.path.basename(os.path.normpath(msg_path))
    msg_name_parts = os.path.splitext(msg_name_complete)
    msg_name = msg_name_parts[0]
    msg_name_ext = msg_name_parts[1]

    extra_email_details_path = os.path.join(target_folder_path,
                                            f'{msg_name}_email_details.txt')
    try:
        with open(extra_email_details_path, 'w', encoding="utf8",
                  errors='ignore') as f:
            f.write(email_content)
    except FileNotFoundError:
        print('The directory does not exist.')

    attachment_msg.Close(0)


def generate_email_folder(message, id_counter):
    try:
        email_id = f"{user_inbox_name} email {id_counter}"
        sender_email = message.SenderEmailAddress  # 43, 57, 56
        sent_on = message.SentOn  # 43, 57, 56
        sender_name = message.SenderName  # 43, 57, 56
        subject = message.Subject  # 43, 57, 56
        attachments = message.Attachments  # 43, 57, 56
        body = message.body  # 43, 57, 56
        # recipients = message.Recipients  # 43, 57, 56
        recipients = ''
        for person in message.Recipients:
            recipients += person.Name + ' '
        attachment_names = ''

        # create a folder for each email
        target_folder_path = os.path.join(base_path, email_id)
        os.mkdir(target_folder_path)

        # checks if there are attachments in the email
        if attachments.Count > 0:
            # Save attachments
            for attachment in attachments:
                try:
                    fileName_and_ext = os.path.splitext(attachment.FileName)
                    fileName = fileName_and_ext[0]
                    ext = fileName_and_ext[1]

                    attachment_names += attachment.FileName + ' '
                    attachment_path = os.path.join(target_folder_path, str(attachment.FileName))
                    attachment.SaveAsFile(attachment_path)  # saves attachment locally

                    if ext.lower() == '.msg':
                        # # doesn't work
                        # breakpoint()
                        # msg_folder_path = os.path.join(target_folder_path, fileName)
                        # os.mkdir(msg_folder_path)
                        # process_msg_files(attachment_path, msg_folder_path)

                        # Does work
                        # print('attachment_path = ' + attachment_path)
                        process_msg_files(attachment_path, target_folder_path)

                except (pywintypes.com_error, PyPDF2.errors.DependencyError,
                        PyPDF2.errors.PdfReadError) \
                        as error:
                    print(error)

        email_content = f'id: {email_id}' \
                        f'\nsender_email: {sender_email}' \
                        f'\nsent_on: {str(sent_on)}' \
                        f'\nsender_name: {sender_name}' \
                        f'\nrecipients: {recipients}' \
                        f'\nsubject: {subject}' \
                        f'\nattachment_names: {attachment_names}' \
                        f'\nbody: {body}'
        # f"\nAttachments: {' '.join(attachment_list)}" \

        # creates a txt file with all the email details in it
        email_details_path = os.path.join(target_folder_path, f'{email_id} details.txt')
        try:
            with open(email_details_path, 'w',
                      encoding="utf8",
                      errors='ignore') as f:
                f.write(email_content)
        except FileNotFoundError:
            print('The directory does not exist.')

    except AttributeError:
        print("email counter = " + str(id_counter))
        print("messages[i].Class =", message.Class)
        print("messages[i].Class =", message.MessageClass)
        # breakpoint()

    message.Close(0)


def process_message(message, id_counter):  # create_email_json
    message_class_list = [43, 53, 56, 57]  # types of items
    # message_report = 46

    if message.Class in message_class_list:  # 43 = email item, 57 = meeting item
        generate_email_folder(message, id_counter)

    else:
        print("email counter = " + str(id_counter))
        print("messages[i].Class =", message.Class)
        print("messages[i].Class =", message.MessageClass)
        # breakpoint()


def process_folders(folder: win32com.client.CDispatch, base_path: str):
    print("\nprocessing", folder.Name)
    global email_counter
    for email_item in folder.Items:
        email_counter += 1
        # if 5000 <= email_counter <= 10100:#1695:
        #     # breakpoint()
        #     process_message(email_item, email_counter)

        process_message(email_item, email_counter)

    # recursively iterate through all subfolders if they exist
    for sub_folder in folder.Folders:
        process_folders(sub_folder, base_path)


def generate_email_json():
    global email_list
    emails_package: dict = {}
    attachment_dict: dict = {}
    email_text = ''
    attachment_list: list = []
    # temp_counter = 0

    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """
        # if temp_counter == 10:
        #     break

        # skips base folder since there's no email files there only email folders
        if subdir == base_path:
            continue

        # email_text = ''
        # attachment_list: list = []

        # current_email_folder_name = os.path.basename(os.path.normpath(subdir))

        for file in files:
            # temp_counter += 1
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]
            email_file_name = user_inbox_name + ' email'

            # breakpoint()

            try:
                # reads in the text file containing email information
                if email_file_name.lower() in file.lower():
                    fileText = ''
                    with open(file_path, encoding="utf8",
                              errors='ignore') as f:
                        lines = f.readlines()
                        fileText = ''.join(lines)
                    email_text = fileText

                elif ext.lower() == '.txt' or ext.lower() == '.html' or \
                        ext.lower() == '.log' or ext.lower() == '.prt' or \
                        ext.lower() == '.jcl' or ext.lower() == '.htm' or \
                        ext.lower() == '.vcf':
                    txt_dict = txt_extract(file_path)
                    attachment_list.append(txt_dict)

                elif ext.lower() == '.pdf':
                    pdf_dict = pdf_extract(file_path)
                    attachment_list.append(pdf_dict)

                elif ext.lower() == '.xls' or ext.lower() == '.xlsx' or \
                        ext.lower() == '.xlsm' or ext.lower() == '.xlsb':
                    xls_dict = xls_extract(file_path, ext.lower())
                    attachment_list.append(xls_dict)

                elif ext.lower() == '.doc' or ext.lower() == '.docx':
                    doc_dict = doc_extract(file_path)
                    attachment_list.append(doc_dict)

                elif ext.lower() == '.ppt':
                    ppt_dict = ppt_extract(file_path)
                    attachment_list.append(ppt_dict)

                elif ext.lower() == '.pptx':
                    pptx_dict = pptx_extract(file_path)
                    attachment_list.append(pptx_dict)

            except Exception as e:
                # breakpoint()
                print(e)

        # check if there are no more sub directories, then finalize package
        if len(dirs) == 0:
            # breakpoint()
            emails_package = {
                "email_content": email_text,
                "Attachments": attachment_list
            }
            email_text = ''
            attachment_list: list = []

        # if emails_package['email_content'] == '': breakpoint()

        # breakpoint()
        if emails_package != {}:
            email_list.append(emails_package)

    # breakpoint()
    create_json(base_path)  # create json file using email list of all emails


def create_json(root):
    global email_list
    full_filename = f'{user_inbox_name}' + ".json"
    full_path = os.path.join(root, full_filename)
    if not os.path.exists(full_path):
        with open(full_path, "w") as outfile:
            initial_json = []
            json_object = json.dumps(initial_json, indent=4)
            outfile.write(json_object)

    with open(full_path, 'r+') as file:
        # breakpoint()
        file_data = email_list

        file.seek(0)
        json.dump(file_data, file, indent=4)


def split_json_chunks(json_file_name: str, chunk_size: int):
    with open(os.path.join(base_path, json_file_name + '.json'), 'r',
              encoding='utf-8') as infile:
        o = json.load(infile)

        output_file_path = os.path.join(base_path, json_file_name)
        for i in range(0, len(o), chunk_size):
            with open(output_file_path + '_' + str(i // chunk_size) + '.json',
                      'w') as outfile:
                json.dump(o[i:i + chunk_size], outfile)


def split_json(json_file_name: str, split_size: int):
    json_length = 0
    double_total = float(0)

    with open(os.path.join(base_path, json_file_name + '.json'), 'r',
              encoding='utf-8') as f1:
        json_content = json.load(f1)
        json_length = len(json_content)
        total = json_length // split_size
        double_total = float(json_length) / float(split_size)

        output_file_name = json_file_name
        output_file_path = os.path.join(base_path, output_file_name)
        for i in range(total + 1):
            json.dump(json_content[i * split_size:(i + 1) * split_size], open(
                output_file_path + "-part_" + str(i + 1) + ".json", 'w',
                encoding='utf8'), ensure_ascii=False, indent=True)

    print(f'size_of_the_split = {split_size}')
    print(f'len(json_content) = {json_length}')
    print(f'total = {double_total}')


# # calculate file size in KB, MB, GB
# def convert_bytes(size):
#     """ Convert bytes to KB, or MB or GB"""
#     for x in ['bytes', 'KB', 'MB', 'GB', 'TB']:
#         if size < 1024.0:
#             return "%3.1f %s" % (size, x)
#         size /= 1024.0
# calculate file size in KB, MB, GB
def convert_bytes(size: int) -> dict:
    """ Convert bytes to KB, or MB or GB"""

    file_size = {}
    # type = ''

    if size < 1024.0:
        type = 'bytes'
    else:
        size /= 1024.0
        type = 'KB'

    file_size = {
        "size": size,
        "type": type
    }

    return file_size


def split_large_files():
    file_counter = 0
    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        for file in files:
            # temp_counter += 1
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]
            casi_file_package = {}

            # file_counter += 1
            file_size = os.path.getsize(file_path)
            file_dict: dict = convert_bytes(file_size)

            fileName_and_ext = os.path.splitext(file)
            fileName = fileName_and_ext[0]
            fileName_ext = fileName_and_ext[1].lower()

            if file_dict["size"] >= 10000:# and fileName_ext == '.txt':
                print()
                print(file_path)
                print(file_size)
                print(file)

                try:
                    if ext.lower() == '.txt' or ext.lower() == '.html' or \
                            ext.lower() == '.log' or ext.lower() == '.prt' or \
                            ext.lower() == '.jcl' or ext.lower() == '.htm' or \
                            ext.lower() == '.vcf':
                        casi_file_package = txt_extract(file_path)

                    elif ext.lower() == '.pdf':
                        casi_file_package = pdf_extract(file_path)

                    elif ext.lower() == '.xls' or ext.lower() == '.xlsx' or \
                            ext.lower() == '.xlsm' or ext.lower() == '.xlsb':
                        casi_file_package = xls_extract(file_path, ext.lower())

                    elif ext.lower() == '.doc' or ext.lower() == '.docx':
                        casi_file_package = doc_extract(file_path)

                    elif ext.lower() == '.ppt':
                        casi_file_package = ppt_extract(file_path)

                    elif ext.lower() == '.pptx':
                        casi_file_package = pptx_extract(file_path)

                    # elif ext.lower() == '.json':
                    #     casi_file_package = json_extract(file_path)

                except Exception as e:
                    print(e)

                if casi_file_package != {}:
                    fp = casi_file_package["file_path"]
                    fc = casi_file_package["file_content"]
                    chunk_size = 1000000
                    chunks = [fc[i:i + chunk_size] for i in
                              range(0, len(fc), chunk_size)]

                    # JSON FORM - makes a JSON file of all the chunks
                    for index, chunk in enumerate(chunks):
                        new_file_name = fileName + f'-part_' \
                                        + str(index) + ".json"

                        output_file_path = os.path.join(output_json_path, new_file_name)

                        # creates a blank json file
                        if not os.path.exists(output_file_path):
                            with open(output_file_path, "w") as outfile:
                                initial_json = []
                                json_object = json.dumps(initial_json, indent=4)
                                outfile.write(json_object)

                        with open(output_file_path, 'r+') as file:
                            file_data = []
                            file_data_dict = {
                                "file_path": fp,
                                "file_content": chunk
                            }
                            file_data.append(file_data_dict)
                            file.seek(0)
                            json.dump(file_data, file, indent=4)

                    # # ORIGINAL - makes a txt file of all the chunks
                    # smallfile = None
                    # for index, chunk in enumerate(chunks):
                    #     new_file_name = fileName + f'-part_' \
                    #                     + str(index) + '.txt'
                    #
                    #     output_file_path = os.path.join(subdir,
                    #                                     new_file_name)
                    #     with open(output_file_path, 'w', encoding="utf8",
                    #               errors='ignore') as f:
                    #         f.write(chunk)


def generate_json_AT_END():
    global casi_file_list
    casi_file_package: dict = {}

    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        # # skips base folder since there's no email files there only email folders
        # if subdir == base_path:
        #     continue

        # casi_file_package: dict = {}

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]
            # email_file_name = user_inbox_name + ' email'
            # casi_file_package: dict = {}


            # NEW IF STATEMENT ADDED
            # file_counter += 1
            file_size = os.path.getsize(file_path)
            file_dict: dict = convert_bytes(file_size)

            fileName_and_ext = os.path.splitext(file)
            fileName = fileName_and_ext[0]
            fileName_ext = fileName_and_ext[1].lower()
            if file_dict["size"] < 10000:
                print()
                print(file_path)
                print(file_size)
                print(file)
                try:
                    # if email_file_name.lower() in file.lower():
                    #     fileText = ''
                    #     with open(file_path, encoding="utf8",
                    #               errors='ignore') as f:
                    #         lines = f.readlines()
                    #         fileText = ''.join(lines)
                    #     email_text = fileText
                    if ext.lower() == '.txt' or ext.lower() == '.html' or \
                            ext.lower() == '.log' or ext.lower() == '.prt' or \
                            ext.lower() == '.jcl' or ext.lower() == '.htm' or \
                            ext.lower() == '.vcf':
                        # if 'SCOTTKJ1' in root:
                        #     breakpoint()
                        casi_file_package = txt_extract(file_path)
                        # attachment_list.append(txt_dict)

                    elif ext.lower() == '.pdf':
                        casi_file_package = pdf_extract(file_path)
                        # attachment_list.append(pdf_dict)

                    elif ext.lower() == '.xls' or ext.lower() == '.xlsx' or \
                            ext.lower() == '.xlsm' or ext.lower() == '.xlsb':
                        casi_file_package = xls_extract(file_path, ext.lower())
                        # attachment_list.append(xls_dict)

                    elif ext.lower() == '.doc' or ext.lower() == '.docx':
                        casi_file_package = doc_extract(file_path)
                        # attachment_list.append(doc_dict)

                    elif ext.lower() == '.ppt':
                        casi_file_package = ppt_extract(file_path)
                        # attachment_list.append(ppt_dict)

                    elif ext.lower() == '.pptx':
                        casi_file_package = pptx_extract(file_path)
                        # attachment_list.append(pptx_dict)

                except Exception as e:
                    # breakpoint()
                    print(e)

                if casi_file_package != {}:
                    casi_file_list.append(casi_file_package)
                    casi_file_package: dict = {}

    # breakpoint()
    create_json_AT_END(output_json_path)  # create json file using email list of all emails


def create_json_AT_END(root):
    global casi_file_list
    folder_name_complete = os.path.basename(os.path.normpath(root))
    folder_name_parts = os.path.splitext(folder_name_complete)
    folder_name = folder_name_parts[0]
    folder_name_ext = folder_name_parts[1]

    dict_per_file = 2

    total = len(casi_file_list) // dict_per_file

    for i in range(total + 1):
        full_filename = f'{folder_name}' + f'-part_{i + 1}' + ".json"
        full_path = os.path.join(root, full_filename)

        # creates a blank json file
        if not os.path.exists(full_path):
            with open(full_path, "w") as outfile:
                initial_json = []
                json_object = json.dumps(initial_json, indent=4)
                outfile.write(json_object)

        with open(full_path, 'r+') as file:
            # breakpoint()
            file_data = casi_file_list[i * dict_per_file:(i + 1) * dict_per_file]
            file.seek(0)
            json.dump(file_data, file, indent=4)


def outlook_scrubbing():
    """
    This function currently works if base_path is location of where all the
    extracted email files are
    :return:
    """
    os.mkdir(base_path)  # make folder to hold all email attachments
    process_folders(user_inbox, base_path)  # iterate through all folders and emails
    unzip_files(base_path)  # unzips any .zip files
    generate_email_json()  # create json file of all extracted files from emails


def outlook_scrubbing_part_2():
    split_large_files()
    generate_json_AT_END()


def main():
    start_time = datetime.now()

    # outlook_scrubbing()
    # file_ext_analysis(base_path)
    # split_json(user_inbox_name)
    # split_large_files(base_path)
    # outlook_scrubbing_part_2()

    print('testing')

    # split_json_chunks(user_inbox_name, 1)
    # split_json(user_inbox_name, 1)

    end_time = datetime.now()

    run_time = end_time - start_time
    print('\nProgram Run Time:', run_time)


if __name__ == '__main__':
    # main()
    print('')
