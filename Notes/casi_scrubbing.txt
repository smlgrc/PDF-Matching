import json
import os

import PyPDF2
import pandas
import pywintypes
import win32com.client
from win32com.client.dynamic import CDispatch
from datetime import datetime
from PyPDF2 import PdfReader, PdfFileReader, PageObject
import magic
import zipfile
from pptx import Presentation
import olefile

# Connect to Outlook
outlook: CDispatch = win32com.client.Dispatch(
    "Outlook.Application").GetNamespace("MAPI")

# base_path: str = os.path.join(r"C:\Users\sga\Documents\My Received Files\CASISupport Copied Local Files\Customer files")

base_path: str = os.path.join(r"C:\Users\sga\Documents\My Received Files\CASISupport Copied Local Files\Customer files")
output_json_path: str = os.path.join(r"C:\Users\sga\Documents\My Received Files\CASISupport Copied Local Files\Customer files JSON Files")

# base_path: str = os.path.join(r"C:\Users\sga\Desktop\casi_testing\Casi Json Files")

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\casi_testing\testing_zip')
# msg_path: str = os.path.join(r'C:\Users\sga\Desktop\casi_testing\testing_zip'
#                              r'\TEST CARNIVAL NEW BLUE LOGO (4.61 KB).msg.msg')

# base_path: str = os.path.join(r'C:\Users\sga\Desktop\casi_testing\split_json_testing')

casi_file_list = []
casi_file_counter = 0
casi_json_counter = 0


def casi_file_count():
    file_count = 0

    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]

            try:
                if ext.lower() == '.txt' or ext.lower() == '.html' or \
                        ext.lower() == '.log' or ext.lower() == '.prt' or \
                        ext.lower() == '.jcl' or ext.lower() == '.htm' or \
                        ext.lower() == '.vcf':
                    file_count += 1

                elif ext.lower() == '.pdf':
                    file_count += 1

                elif ext.lower() == '.xls' or ext.lower() == '.xlsx' or \
                        ext.lower() == '.xlsm' or ext.lower() == '.xlsb':
                    file_count += 1

                elif ext.lower() == '.doc' or ext.lower() == '.docx':
                    file_count += 1

                elif ext.lower() == '.ppt':
                    file_count += 1
                    # casi_file_package = ppt_extract(file_path)
                    # attachment_list.append(ppt_dict)

                elif ext.lower() == '.pptx':
                    file_count += 1
                    # casi_file_package = pptx_extract(file_path)
                    # attachment_list.append(pptx_dict)

            except Exception as e:
                # breakpoint()
                print(e)
    print(f'total valid files = {file_count}')


def pptx_extract(attachment_path: str):
    # creating an object
    pptx = Presentation(attachment_path)

    text_list = []

    # print text from powerpoint
    for slide in pptx.slides:
        for shape in slide.shapes:
            if not shape.has_text_frame:
                continue
            for paragraph in shape.text_frame.paragraphs:
                for run in paragraph.runs:
                    # print('\n' + run.text)
                    text_list.append(run.text)
    # for i in text_list:
    #     print(i)
    fileText = ' '.join(text_list)

    attachment_dict: dict = \
        {
            'file_path': attachment_path,
            'file_content': fileText
        }
    return attachment_dict


def ppt_extract(attachment_path: str):
    ppt_app = win32com.client.GetObject(attachment_path)

    text_list = []

    for slide in ppt_app.Slides:
        for shape in slide.Shapes:
            if not shape.HasTextFrame:
                continue
            for lines in shape.TextFrame.TextRange:
                text_list.append(lines.text)
    # for i in text_list:
    #     print(i)
    fileText = ' '.join(text_list)

    attachment_dict: dict = \
        {
            'file_path': attachment_path,
            'file_content': fileText
        }
    ppt_app.Close()
    return attachment_dict


def pdf_extract(attachment_path: str) -> dict:
    pdfFileObj = open(attachment_path, 'rb')
    pdfTxt: str = ''
    try:
        pdfReader: PdfFileReader = PyPDF2.PdfFileReader(pdfFileObj,
                                                        strict=False)
        print('Number of PDF pages = ' + str(pdfReader.numPages))

        pdfPages: list[PageObject] = pdfReader.pages

        print('\n=== Page Extracts ===')
        for i in range(len(pdfPages)):
            pageNum = i + 1
            pageObj: PageObject = pdfReader.getPage(i)
            pageTxt: str = pageObj.extractText()
            pdfTxt += pageTxt
    except Exception as e:  # PyPDF2.errors.PdfReadError:
        print(e)
    finally:
        attachment_dict: dict = \
            {
                'file_path': attachment_path,
                'file_content': pdfTxt
            }
        # attachment_list.append(attachment_dict)
    pdfFileObj.close()
    return attachment_dict


def txt_extract(attachment_path: str) -> dict:
    fileText = ''
    with open(attachment_path, encoding="utf8", errors='ignore') as f:
        lines = f.readlines()
        fileText = ''.join(lines)

    attachment_dict: dict = \
        {
            'file_path': attachment_path,
            'file_content': fileText
        }
    return attachment_dict


def xls_extract(attachment_path: str, ext: str) -> dict:
    attachment_dict = {}
    eng: str = "xlrd"

    if ext.lower() == '.xlsx' or ext.lower() == '.xlsm':
        eng = "openpyxl"
    elif ext.lower() == '.xlsb':
        eng = "pyxlsb"

    # read all sheets together.
    all_sheets_df = pandas.read_excel(attachment_path, na_values="Missing",
                                      na_filter=False, sheet_name=None,
                                      engine=eng)  # idk about the warning
    content = ''
    for key, value in all_sheets_df.items():
        content += '\n' + key + ' : ' + str(value)
    attachment_dict['file_path'] = attachment_path
    attachment_dict['file_content'] = content
    return attachment_dict


def doc_extract(attachment_path: str) -> dict:
    attachment_dict = {}
    word = win32com.client.Dispatch("Word.Application")
    word.visible = False
    wb = word.Documents.Open(attachment_path)
    doc = word.ActiveDocument
    content = str(doc.Content)
    attachment_dict['file_path'] = attachment_path
    attachment_dict['file_content'] = content
    doc.Close()
    return attachment_dict


def unzip_files(rootdir):
    for subdir, dirs, files in os.walk(rootdir):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """
        for file in files:
            path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(path)
            root = root_and_ext[0]
            ext = root_and_ext[1]

            # breakpoint()
            if ext.lower() == '.zip':
                zipFileName_and_ext = os.path.splitext(file)
                zipFileName = zipFileName_and_ext[0]
                zip_ext = zipFileName_and_ext[1]
                try:
                    with zipfile.ZipFile(path, 'r') as zip_ref:
                        # zip_ref.extractall(subdir)

                        counter = 0
                        zipinfos = zip_ref.infolist()

                        # iterate through each file in zip folder
                        for zipinfo in zipinfos:
                            counter += 1

                            # fileName = 'file1' | fileName_ext = '.pdf'
                            fileName_and_ext = os.path.splitext(zipinfo.filename)
                            fileName = fileName_and_ext[0]
                            fileName_ext = fileName_and_ext[1]

                            new_file_name = fileName + f'_zipExtract_' \
                                            + str(counter) + fileName_ext

                            # modify the name of the file before extracting
                            zipinfo.filename = new_file_name
                            zip_ref.extract(zipinfo, subdir)

                except Exception as e:
                    print(e)


def process_msg(msg_path: str, target_folder_path: str):
    try:
        attachment_msg = outlook.OpenSharedItem(msg_path)
        senderEmail = attachment_msg.SenderEmailAddress  # 43, # 57, 56
        sentOn = attachment_msg.SentOn  # 43, 57, 56
        senderName = attachment_msg.SenderName  # 43, 57, 56
        subjectMsg = attachment_msg.Subject  # 43, 57, 56
        attachmentsMsg = attachment_msg.Attachments  # 43, 57, 56
        bodyMsg = attachment_msg.body  # 43, 57, 56
        attachment_names = ''

        # checks if there are attachments in the email
        if attachmentsMsg.Count > 0:
            # Save attachments
            counter = 0
            for attachment in attachmentsMsg:
                counter += 1
                try:
                    fileName_and_ext = os.path.splitext(attachment.FileName)
                    fileName = fileName_and_ext[0]
                    ext = fileName_and_ext[1]
                    attachment_names += attachment.FileName + ' '

                    new_attachment_name = fileName + '_msgExtract_' + \
                                          str(counter) + ext
                    attachment_path = os.path.join(target_folder_path,
                                                   new_attachment_name)
                    attachment.SaveAsFile(attachment_path)  # saves attachment locally

                except (pywintypes.com_error, PyPDF2.errors.DependencyError,
                        PyPDF2.errors.PdfReadError) \
                        as error:
                    print(error)
        email_content = f'\nsender_email: {senderEmail}' \
                        f'\nsent_on: {str(sentOn)}' \
                        f'\nsender_name: {senderName}' \
                        f'\nsubject: {subjectMsg}' \
                        f'\nattachment_names: {attachment_names}' \
                        f'\nbody: {bodyMsg}'

        # creates a txt file with all the email details in it
        msg_name_complete = os.path.basename(os.path.normpath(msg_path))
        msg_name_parts = os.path.splitext(msg_name_complete)
        msg_name = msg_name_parts[0]
        msg_name_ext = msg_name_parts[1]

        extra_email_details_path = os.path.join(target_folder_path,
                                                f'{msg_name}_email_details.txt')
        # breakpoint()
        try:
            with open(extra_email_details_path, 'w', encoding="utf8",
                      errors='ignore') as f:
                f.write(email_content)
        except FileNotFoundError:
            print('The directory does not exist.')

        attachment_msg.Close(0)
    except Exception as error:
        print(f'There was an error processing {msg_path}')
        print(error)


def file_ext_analysis(rootdir):
    file_types = {}

    for subdir, dirs, files in os.walk(rootdir):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """
        breakpoint()
        for file in files:
            path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(path)
            root = root_and_ext[0]
            ext = root_and_ext[1]

            # fileName_and_ext = os.path.splitext(file)
            # fileName = fileName_and_ext[0]
            # ext = fileName_and_ext[1]
            #
            # if '_msg_extract' in fileName:
            #     breakpoint()

            # print(path)
            # my tool to check the types of files im looking at
            if ext.lower() == '.zip':
                breakpoint()
                print('\n' + path)
                print(magic.from_file(path))
                print(magic.from_file(path, mime=True) + '\n')

                # msg = outlook.OpenSharedItem(path)
                # msg_a = msg.Attachments
                # breakpoint()
                # msg.Close(0)

            # if ext.lower() == '.zip':
            #     breakpoint()
            if ext in file_types:
                file_types[ext] += 1
            else:
                file_types[ext] = 1
    # counter += if_counter + else_counter
    # breakpoint()
    sorted_list: list = sorted(file_types.items(), key=lambda item: item[1])[
                        ::-1]
    sorted_dict = dict(sorted_list)
    for key, value in sorted_dict.items():
        print(key + ' : ' + str(value))


def generate_casi_json():
    global casi_file_list
    casi_file_package: dict = {}

    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        # # skips base folder since there's no email files there only email folders
        # if subdir == base_path:
        #     continue

        # casi_file_package: dict = {}

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]
            # email_file_name = user_inbox_name + ' email'
            # casi_file_package: dict = {}


            # file_counter += 1
            file_size = os.path.getsize(file_path)
            file_dict: dict = convert_bytes(file_size)

            fileName_and_ext = os.path.splitext(file)
            fileName = fileName_and_ext[0]
            fileName_ext = fileName_and_ext[1].lower()

            if file_dict["size"] < 10000:# and fileName_ext == '.txt':
                print()
                print(file_path)
                print(file_size)
                print(file)

                try:
                    # if email_file_name.lower() in file.lower():
                    #     fileText = ''
                    #     with open(file_path, encoding="utf8",
                    #               errors='ignore') as f:
                    #         lines = f.readlines()
                    #         fileText = ''.join(lines)
                    #     email_text = fileText
                    if ext.lower() == '.txt' or ext.lower() == '.html' or \
                            ext.lower() == '.log' or ext.lower() == '.prt' or \
                            ext.lower() == '.jcl' or ext.lower() == '.htm' or \
                            ext.lower() == '.vcf':
                        casi_file_package = txt_extract(file_path)
                        # attachment_list.append(txt_dict)

                    elif ext.lower() == '.pdf':
                        casi_file_package = pdf_extract(file_path)
                        # attachment_list.append(pdf_dict)

                    elif ext.lower() == '.xls' or ext.lower() == '.xlsx' or \
                            ext.lower() == '.xlsm' or ext.lower() == '.xlsb':
                        casi_file_package = xls_extract(file_path, ext.lower())
                        # attachment_list.append(xls_dict)

                    elif ext.lower() == '.doc' or ext.lower() == '.docx':
                        casi_file_package = doc_extract(file_path)
                        # attachment_list.append(doc_dict)

                    elif ext.lower() == '.ppt':
                        casi_file_package = ppt_extract(file_path)
                        # attachment_list.append(ppt_dict)

                    elif ext.lower() == '.pptx':
                        casi_file_package = pptx_extract(file_path)
                        # attachment_list.append(pptx_dict)

                except Exception as e:
                    print(e)

                if casi_file_package != {}:
                    casi_file_list.append(casi_file_package)
                    casi_file_package: dict = {}

                if len(casi_file_list) == 5:
                    create_json(output_json_path)
                    casi_file_list = []


def generate_casi_json_AT_END():
    global casi_file_list
    casi_file_package: dict = {}

    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        # # skips base folder since there's no email files there only email folders
        # if subdir == base_path:
        #     continue

        # casi_file_package: dict = {}

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]
            # email_file_name = user_inbox_name + ' email'
            # casi_file_package: dict = {}


            # NEW IF STATEMENT ADDED
            # file_counter += 1
            file_size = os.path.getsize(file_path)
            file_dict: dict = convert_bytes(file_size)

            fileName_and_ext = os.path.splitext(file)
            fileName = fileName_and_ext[0]
            fileName_ext = fileName_and_ext[1].lower()
            if file_dict["size"] < 10000:
                print()
                print(file_path)
                print(file_size)
                print(file)
                try:
                    # if email_file_name.lower() in file.lower():
                    #     fileText = ''
                    #     with open(file_path, encoding="utf8",
                    #               errors='ignore') as f:
                    #         lines = f.readlines()
                    #         fileText = ''.join(lines)
                    #     email_text = fileText
                    if ext.lower() == '.txt' or ext.lower() == '.html' or \
                            ext.lower() == '.log' or ext.lower() == '.prt' or \
                            ext.lower() == '.jcl' or ext.lower() == '.htm' or \
                            ext.lower() == '.vcf':
                        # if 'SCOTTKJ1' in root:
                        #     breakpoint()
                        casi_file_package = txt_extract(file_path)
                        # attachment_list.append(txt_dict)

                    elif ext.lower() == '.pdf':
                        casi_file_package = pdf_extract(file_path)
                        # attachment_list.append(pdf_dict)

                    elif ext.lower() == '.xls' or ext.lower() == '.xlsx' or \
                            ext.lower() == '.xlsm' or ext.lower() == '.xlsb':
                        casi_file_package = xls_extract(file_path, ext.lower())
                        # attachment_list.append(xls_dict)

                    elif ext.lower() == '.doc' or ext.lower() == '.docx':
                        casi_file_package = doc_extract(file_path)
                        # attachment_list.append(doc_dict)

                    elif ext.lower() == '.ppt':
                        casi_file_package = ppt_extract(file_path)
                        # attachment_list.append(ppt_dict)

                    elif ext.lower() == '.pptx':
                        casi_file_package = pptx_extract(file_path)
                        # attachment_list.append(pptx_dict)

                except Exception as e:
                    # breakpoint()
                    print(e)

                if casi_file_package != {}:
                    casi_file_list.append(casi_file_package)
                    casi_file_package: dict = {}

    # breakpoint()
    create_json_AT_END(output_json_path)  # create json file using email list of all emails


def create_json_AT_END(root):
    global casi_file_list
    folder_name_complete = os.path.basename(os.path.normpath(root))
    folder_name_parts = os.path.splitext(folder_name_complete)
    folder_name = folder_name_parts[0]
    folder_name_ext = folder_name_parts[1]

    dict_per_file = 2

    total = len(casi_file_list) // dict_per_file

    for i in range(total + 1):
        full_filename = f'{folder_name}' + f'-part_{i + 1}' + ".json"
        full_path = os.path.join(root, full_filename)

        # creates a blank json file
        if not os.path.exists(full_path):
            with open(full_path, "w") as outfile:
                initial_json = []
                json_object = json.dumps(initial_json, indent=4)
                outfile.write(json_object)

        with open(full_path, 'r+') as file:
            # breakpoint()
            file_data = casi_file_list[i * dict_per_file:(i + 1) * dict_per_file]
            file.seek(0)
            json.dump(file_data, file, indent=4)


def create_json(root):
    global casi_file_list
    global casi_json_counter
    folder_name_complete = os.path.basename(os.path.normpath(root))
    folder_name_parts = os.path.splitext(folder_name_complete)
    folder_name = folder_name_parts[0]
    folder_name_ext = folder_name_parts[1]
    casi_json_counter += 1

    full_filename = f'{folder_name}-part_' + str(casi_json_counter) + ".json"
    full_path = os.path.join(root, full_filename)
    if not os.path.exists(full_path):
        with open(full_path, "w") as outfile:
            initial_json = []
            json_object = json.dumps(initial_json, indent=4)
            outfile.write(json_object)

    with open(full_path, 'r+') as file:
        # breakpoint()
        file_data = casi_file_list

        file.seek(0)
        json.dump(file_data, file, indent=4)


def process_casi_msg_files(base_path: str):
    # emails_package: dict = {}
    # attachment_dict: dict = {}
    # email_text = ''
    # attachment_list: list = []

    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        # # skips base folder since there's no email files there only email folders
        # if subdir == base_path:
        #     continue

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]

            # breakpoint()

            if ext.lower() == '.msg':
                # print(file_path)
                # breakpoint()
                process_msg(file_path, subdir)
                # breakpoint()


def analyze_zip_files():
    # base_path: str = os.path.join(r"C:\Users\sga\Documents\My Received Files\CASISupport Copied Local Files\Customer files")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\email_testing\create_email_folder_testing\Randy Inbox Attachments")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\email_testing\create_email_folder_testing\Lisa Inbox 1 Attachments")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\email_testing\create_email_folder_testing\Lisa Inbox 2 Attachments")

    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """
        for file in files:
            path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(path)
            root = root_and_ext[0]
            ext = root_and_ext[1]

            # breakpoint()
            if ext.lower() == '.zip':
                zipFileName_and_ext = os.path.splitext(file)
                zipFileName = zipFileName_and_ext[0]
                zip_ext = zipFileName_and_ext[1]
                try:
                    with zipfile.ZipFile(path, 'r') as zip_ref:
                        zipinfos = zip_ref.infolist()
                        for zip in zipinfos:
                            print()
                            # print(path)
                            print(zip.filename)
                except Exception as e:
                    print(e)


def print_msg_report(msg_filepath):
    for subdir, dirs, files in os.walk(msg_filepath):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        # skips base folder since there's no email files there only email folders
        if subdir == msg_filepath:
            continue

        # email_text = ''
        # attachment_list: list = []

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]


def analyze_msg_files(path: str):
    for subdir, dirs, files in os.walk(path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir

        this method only works when looking at the extracts of pst files, 
        no zip or msgs extracted yet
        """

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]  # .msg

            if 'RPIE-2013 Online Form Available - Due Date June 2 2014' in root:
                breakpoint()

            if ext.lower() == '.msg':
                try:
                    attachment_msg = outlook.OpenSharedItem(file_path)
                    attachmentsMsg = attachment_msg.Attachments

                    # checks if there are attachments in the email
                    if attachmentsMsg.Count > 0:
                        # Save attachments
                        counter = 0
                        for attachment in attachmentsMsg:
                            counter += 1
                            attachmentName_and_ext = os.path.splitext(
                                attachment.FileName)
                            attachmentName = attachmentName_and_ext[0]
                            attachmentExt = attachmentName_and_ext[1]

                            print('\nfile path = ' + file_path)
                            print('attachment file name = ' + attachment.FileName)

                            # breakpoint()

                            if attachmentExt.lower() == '.msg':
                                # breakpoint()
                                new_attachment_name = attachmentName + '_msgExtract_' + str(counter)
                                full_attachment_name = new_attachment_name + ext
                    attachment_msg.Close(0)

                except Exception as error:
                    print('\nfile path = ' + file_path)
                    print(error)


def analyze_msg_files_OLD(path: str):
    for subdir, dirs, files in os.walk(path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        
        this method only works when looking at the extracts of pst files, 
        no zip or msgs extracted yet
        """

        # # skips for 5th base path in casi testing
        # # skips base folder since there's no email files there only email folders
        # if subdir == base_path:
        #     continue

        # email_text = ''
        # attachment_list: list = []

        for file in files:
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]  # 'C:\\Users\\sga\\Desktop\\email_testing\\create_email_folder_testing\\Lisa Inbox 1 Attachments\\Lisa Inbox 1 email 1695\\FW EXTERNAL Thank you for your request Need Payment method updated to ACH and Case Id-ref_255697ref'
            ext = root_and_ext[1]  # .msg

            # breakpoint()

            if ext.lower() == '.msg':
                try:
                    # print(file_path)

                    attachment_msg = outlook.OpenSharedItem(file_path)
                    attachmentsMsg = attachment_msg.Attachments
                    # checks if there are attachments in the email
                    if attachmentsMsg.Count > 0:
                        # Save attachments
                        counter = 0
                        for attachment in attachmentsMsg:
                            counter += 1
                            attachmentName_and_ext = os.path.splitext(
                                attachment.FileName)
                            attachmentName = attachmentName_and_ext[0]
                            attachmentExt = attachmentName_and_ext[1]

                            # breakpoint()

                            if attachmentExt.lower() == '.msg':

                                new_attachment_name = attachmentName + '_msgExtract_' + str(counter)
                                full_attachment_name = new_attachment_name + ext

                                # attachment_folder_path = os.path.join(
                                #     root,
                                #     new_attachment_name)

                                print()
                                print(root)
                                print()
                                breakpoint()

                                # TODO: MAKE NEW FOLDER AND PUT MESSAGE ATTACHEMENT IN THERE
                                os.mkdir(root)

                                attachment_file_path = os.path.join(
                                    root,
                                    full_attachment_name)

                                # attachment.SaveAsFile(rf"{attachment_folder_path}" + full_attachment_name)  # saves attachment locally
                                attachment.SaveAsFile(attachment_file_path)

                                # breakpoint()
                                # analyze_msg_files(root)


                except Exception as error:
                    print(error)


def split_json_OLD(json_file_name: str):
    json_length = 0
    double_total = float(0)
    size_of_the_split = 0

    with open(os.path.join(base_path, json_file_name + '.json'), 'r',
              encoding='utf-8') as f1:
        json_content = json.load(f1)
        size_of_the_split = 500
        json_length = len(json_content)
        total = json_length // size_of_the_split
        double_total = float(json_length) / float(size_of_the_split)

        # output_file_name = json_file_name
        # output_file_path = os.path.join(base_path, output_file_name)
        # for i in range(total + 1):
        #     json.dump(json_content[i * size_of_the_split:(i + 1) * size_of_the_split], open(
        #         output_file_path + "-part_" + str(i + 1) + ".json", 'w',
        #         encoding='utf8'), ensure_ascii=False, indent=True)

    print(f'size_of_the_split = {size_of_the_split}')
    print(f'len(json_content) = {json_length}')
    print(f'total = {double_total}')


def split_json(json_file_name: str, split_size: int):
    json_length = 0
    double_total = float(0)

    with open(os.path.join(base_path, json_file_name + '.json'), 'r',
              encoding='utf-8') as f1:
        json_content = json.load(f1)
        json_length = len(json_content)
        total = json_length // split_size
        double_total = float(json_length) / float(split_size)

        output_file_name = json_file_name
        output_file_path = os.path.join(base_path, output_file_name)
        for i in range(total + 1):
            json.dump(json_content[i * split_size:(i + 1) * split_size], open(
                output_file_path + "-part_" + str(i + 1) + ".json", 'w',
                encoding='utf8'), ensure_ascii=False, indent=True)

    print(f'size_of_the_split = {split_size}')
    print(f'len(json_content) = {json_length}')
    print(f'total = {double_total}')


# calculate file size in KB, MB, GB
def convert_bytes(size: int) -> dict:
    """ Convert bytes to KB, or MB or GB"""

    file_size = {}
    # type = ''

    if size < 1024.0:
        type = 'bytes'
    else:
        size /= 1024.0
        type = 'KB'

    file_size = {
        "size": size,
        "type": type
    }

    return file_size


def split_large_files():
    file_counter = 0
    for subdir, dirs, files in os.walk(base_path):
        """
        subdir = current parent folder name
        dirs = list of directory names in subdir
        files = list of file names in subdir
        """

        for file in files:
            # temp_counter += 1
            file_path = os.path.join(subdir, file)
            root_and_ext = os.path.splitext(file_path)
            root = root_and_ext[0]
            ext = root_and_ext[1]
            casi_file_package = {}

            # file_counter += 1
            file_size = os.path.getsize(file_path)
            file_dict: dict = convert_bytes(file_size)

            fileName_and_ext = os.path.splitext(file)
            fileName = fileName_and_ext[0]
            fileName_ext = fileName_and_ext[1].lower()

            if file_dict["size"] >= 10000:# and fileName_ext == '.txt':
                print()
                print(file_path)
                print(file_size)
                print(file)

                try:
                    if ext.lower() == '.txt' or ext.lower() == '.html' or \
                            ext.lower() == '.log' or ext.lower() == '.prt' or \
                            ext.lower() == '.jcl' or ext.lower() == '.htm' or \
                            ext.lower() == '.vcf':
                        casi_file_package = txt_extract(file_path)

                    elif ext.lower() == '.pdf':
                        casi_file_package = pdf_extract(file_path)

                    elif ext.lower() == '.xls' or ext.lower() == '.xlsx' or \
                            ext.lower() == '.xlsm' or ext.lower() == '.xlsb':
                        casi_file_package = xls_extract(file_path, ext.lower())

                    elif ext.lower() == '.doc' or ext.lower() == '.docx':
                        casi_file_package = doc_extract(file_path)

                    elif ext.lower() == '.ppt':
                        casi_file_package = ppt_extract(file_path)

                    elif ext.lower() == '.pptx':
                        casi_file_package = pptx_extract(file_path)

                except Exception as e:
                    print(e)

                if casi_file_package != {}:
                    fp = casi_file_package["file_path"]
                    fc = casi_file_package["file_content"]
                    chunk_size = 1000000
                    chunks = [fc[i:i + chunk_size] for i in
                              range(0, len(fc), chunk_size)]

                    # JSON FORM - makes a JSON file of all the chunks
                    for index, chunk in enumerate(chunks):
                        new_file_name = fileName + f'-part_' \
                                        + str(index) + ".json"

                        output_file_path = os.path.join(output_json_path, new_file_name)#os.path.join(subdir, new_file_name)

                        # creates a blank json file
                        if not os.path.exists(output_file_path):
                            with open(output_file_path, "w") as outfile:
                                initial_json = []
                                json_object = json.dumps(initial_json, indent=4)
                                outfile.write(json_object)

                        with open(output_file_path, 'r+') as file:
                            file_data = []
                            file_data_dict = {
                                "file_path": fp,
                                "file_content": chunk
                            }
                            file_data.append(file_data_dict)
                            file.seek(0)
                            json.dump(file_data, file, indent=4)

                    # # ORIGINAL - makes a txt file of all the chunks
                    # smallfile = None
                    # for index, chunk in enumerate(chunks):
                    #     new_file_name = fileName + f'-part_' \
                    #                     + str(index) + '.txt'
                    #
                    #     output_file_path = os.path.join(subdir,
                    #                                     new_file_name)
                    #     with open(output_file_path, 'w', encoding="utf8",
                    #               errors='ignore') as f:
                    #         f.write(chunk)


def casi_scrubbing():
    # process_casi_msg_files(base_path)  # iterate through all folders and msgs
    # unzip_files(base_path)  # unzips any .zip files
    # generate_casi_json()

    split_large_files()
    generate_casi_json_AT_END()

    # split_json("Customer files", 1)


def main():
    start_time = datetime.now()

    # casi_scrubbing()

    # file_ext_analysis(base_path)
    # split_json('Customer files')
    # casi_file_count()


    # base_path: str = os.path.join(r"C:\Users\sga\Documents\My Received Files\CASISupport Copied Local Files\Customer files")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\email_testing\create_email_folder_testing\Randy Inbox Attachments")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\email_testing\create_email_folder_testing\Lisa Inbox 1 Attachments")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\email_testing\create_email_folder_testing\Lisa Inbox 2 Attachments")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\casi_testing\Lisa Inbox 1 email 1695")
    # base_path: str = os.path.join(r"C:\Users\sga\Desktop\email_testing\create_email_folder_testing\Lisa Inbox 1 Attachments")
    # analyze_msg_files(base_path)

    print('test')

    end_time = datetime.now()

    run_time = end_time - start_time
    print('\nProgram Run Time:', run_time)


if __name__ == '__main__':
    # main()
    print('')